module main {

  // Import types
  // type addr_t     = common.addr_t;
  // type mem_t      = common.mem_t;
  // type word_t     = common.word_t;
  // type op_t       = common.op_t;
  type * = common.*;
  // type hit_t      = common.hit_t;
  type regindex_t = cpu.regindex_t;

  // instruction memory is the same for both CPUs.
  var imem : mem_t;

  var s_addr : addr_t;
  var s_val  : word_t;
  var l_addr : addr_t;
  var l_val  : word_t;

  var ts_addr : addr_t;
  var ts_val  : word_t;
  var tl_addr : addr_t;
  var tl_val  : word_t;

  var chit    : hit_t;

  var o       : op_t;

  var pc      : word_t;
  
  // Create two instances of the CPU module.
  instance cpu_i_1 : cpu(imem : (imem));
  // instance cpu_i_2 : cpu(imem : (imem));

  init {
  }

  procedure populate()
    modifies o, chit, pc, s_addr, s_val, l_addr, l_val, cpu_i_1;
  {
    call (o) = cpu_i_1.get_op();
    chit = cpu_i_1.cacheHit;
    call (pc) = cpu_i_1.get_pc();
    
    if (o == op_store) {
      call (s_addr, s_val) = cpu_i_1.get_store_details(pc);
    }
    if (o == op_load && chit == c_hit) {
      call (l_addr, l_val) = cpu_i_1.get_load_details(pc);
    }
  }

  next {
    // Invoke CPU 1 and CPU 2.
    next (cpu_i_1);
    call populate();
    // call (o') = cpu_i_1.get_op();
    // chit' = cpu_i_1.cacheHit;
    // call (pc') = cpu_i_1.get_pc();
    
    // if (o' == op_store) {
    //   call (s_addr', s_val') = cpu_i_1.get_store_details(pc');
    // }
    // if (o' == op_load && chit' == c_hit) {
    //   call (l_addr', l_val') = cpu_i_1.get_load_details(pc');
    // }
        // assert(false);

  }
  
  // // These are our properties.
  // invariant eq_regs : 
  //   (forall (ri : regindex_t) :: cpu_i_1.regs[ri] == cpu_i_2.regs[ri]);
  // //invariant eq_mem  : 
  // //  (forall (a : addr_t) :: cpu_i_1.dmem[a] == cpu_i_2.dmem[a]);
  // invariant eq_pc   : (cpu_i_1.pc == cpu_i_2.pc);
  // invariant eq_inst : (cpu_i_1.inst == cpu_i_2.inst);
  // property[LTL] (cpu_i_1.op == op_store) && X(cpu_i_1.op != op_store) ==> 

  property[LTL] cache_property : G(( 
    (  
      ((o == op_add) && (ts_addr == s_addr) && (ts_val == s_val))
       &&
      U(!((o == op_store) && (ts_addr == s_addr)), (o == op_load && chit == c_hit) && (tl_addr == l_addr) && (tl_val == s_val))
    )
    ==>
    (
      (tl_val == ts_val)
    )

   ));

  // Proof script.
  control {
    // v = induction;
    // v = unroll(5);
    v = bmc[properties = [cache_property]](10);
    check;
    print_results;
    v.print_cex(cpu_i_1.memory.dmem, cpu_i_1.memory.dcache, cpu_i_1.pc, imem, cpu_i_1.memory.c2mem_map, o, s_addr, s_val, l_addr, l_val, chit, cpu_i_1.waitLongCall);
  }
}
